# Глава 0: Введение

## Что такое sysdiag?

**sysdiag** — это единый бинарный файл на Go, который выполняет комплексный анализ производительности Linux-сервера. Он собирает метрики из ядра, анализирует их и выдаёт структурированный JSON-отчёт, который может использоваться людьми, AI/LLM или системами мониторинга.

Представьте, что вы запускаете 30+ диагностических команд одновременно, но с единым структурированным выводом и автоматическим анализом.

## Проблема: «Сервер тормозит»

Каждый системный администратор слышал это. Сервер медленный. Но что значит «медленный»?

- CPU перегружен?
- Приложение ждёт дисковый I/O?
- Утечка памяти вызывает swapping?
- Сеть теряет пакеты?
- Контейнер достигает CPU-квоты?

Без системного подхода вы запускаете случайные команды и гадаете. **sysdiag** предоставляет этот системный подход.

## Методология USE

sysdiag построен на **методологии USE** Брендана Грегга — фреймворке для анализа производительности систем. USE расшифровывается как:

| Буква | Значение | Вопрос |
|-------|----------|--------|
| **U** | Utilization (Утилизация) | Насколько загружен этот ресурс? (0–100%) |
| **S** | Saturation (Насыщение) | Есть ли очередь на работу? (runqueue, swap, очередь I/O) |
| **E** | Errors (Ошибки) | Были ли ошибки? (drops, ретрансмиссии, ECC) |

Вы задаёте эти три вопроса для **каждого** системного ресурса:

```
┌──────────┬──────────────────────┬──────────────────────┬────────────────────┐
│ Ресурс   │ Утилизация           │ Насыщение            │ Ошибки             │
├──────────┼──────────────────────┼──────────────────────┼────────────────────┤
│ CPU      │ 100% - idle%         │ load_avg / num_cpus  │ —                  │
│ Память   │ (total-available)/   │ swap_used / swap_    │ major page faults  │
│          │ total × 100          │ total × 100          │ (OOM events)       │
│ Диск     │ io_time / interval   │ io_in_progress       │ ошибки устройства  │
│ Сеть     │ использование        │ drops, overflows     │ errors, retrans    │
│          │ полосы               │                      │                    │
└──────────┴──────────────────────┴──────────────────────┴────────────────────┘
```

### Почему USE работает

Без USE вы можете проверить утилизацию CPU и остановиться. Но высокая утилизация CPU без насыщения — это совершенно нормально: вы используете то, за что заплатили. Проблема начинается, когда появляется насыщение (работа стоит в очереди) или возникают ошибки.

USE гарантирует, что вы проверите **все три измерения** для **каждого ресурса**, и не пропустите ни одного узкого места.

## Обзор архитектуры

```
┌──────────────────────────────────────────────────────────────────┐
│                        sysdiag binary                            │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐    ┌──────────────┐    ┌──────────────────────┐ │
│  │   CLI       │    │ Оркестратор  │    │    Вывод             │ │
│  │  (cobra)    │───▶│(параллельный)│───▶│  JSON / FlameGraph   │ │
│  └─────────────┘    │  + профили   │    │  + AI Prompt         │ │
│                     │  + сигналы   │    └──────────────────────┘ │
│                     └──────┬───────┘                             │
│                            │                                     │
│              ┌─────────────┼─────────────┐                       │
│              ▼             ▼             ▼                       │
│  ┌───────────────┐ ┌──────────────┐ ┌──────────────┐            │
│  │  Уровень 1    │ │  Уровень 2   │ │  Уровень 3   │            │
│  │  Коллекторы   │ │  BCC         │ │  eBPF        │            │
│  │  (procfs/     │ │  Executor    │ │  (cilium/    │            │
│  │   sysfs)      │ │  + Security  │ │   ebpf)      │            │
│  │               │ │  + Parsers   │ │              │            │
│  │  7 коллекторов│ │  20 тулзов   │ │  BTF/CO-RE   │            │
│  └───────────────┘ └──────────────┘ └──────────────┘            │
│              │             │             │                       │
│              └─────────────┼─────────────┘                       │
│                            ▼                                     │
│              ┌──────────────────────────┐                        │
│              │     Слой модели          │                        │
│              │  • Report (JSON-схема)   │                        │
│              │  • USE-метрики           │                        │
│              │  • Обнаружение аномалий  │                        │
│              │  • Health score (0-100)  │                        │
│              │  • Рекомендации          │                        │
│              └──────────────────────────┘                        │
└──────────────────────────────────────────────────────────────────┘
```

## Уровни сбора данных (Tiers)

Не каждая Linux-система имеет одинаковые возможности. Минимальный контейнер может иметь только `/proc`, а bare-metal сервер с современным ядром может использовать нативный eBPF. sysdiag справляется с этим через три уровня:

### Уровень 1 — procfs/sysfs (всегда доступен)

Чтение виртуальных файловых систем, которые ядро Linux предоставляет каждому процессу:

- `/proc/stat` — утилизация CPU по каждому ядру
- `/proc/meminfo` — детализация памяти
- `/proc/diskstats` — счётчики I/O блочных устройств
- `/proc/net/dev` — статистика сетевых интерфейсов
- `/sys/block/*/queue/scheduler` — параметры I/O планировщика
- `/sys/fs/cgroup/` — лимиты ресурсов контейнера

**Не требует root.** Работает на любом ядре Linux. Это 7 встроенных коллекторов.

### Уровень 2 — BCC Tools (root + bcc-tools)

Инструменты BCC (BPF Compiler Collection) трассируют функции ядра в реальном времени:

- `runqlat` — гистограмма задержки в CPU-планировщике
- `biolatency` — задержка блочного I/O по дискам
- `tcpconnlat` — время установления TCP-соединения
- `profile` — CPU flame graph через сэмплирование стеков

**Активация**: Используйте `--profile standard` (часть инструментов) или `--profile deep` (все инструменты). **Требуют root** и пакет `bcc-tools`.

### Уровень 3 — Нативный eBPF (root + ядро ≥ 5.8)

Использование Go-библиотеки cilium/ebpf для загрузки BPF-программ напрямую — без Python, без внешних зависимостей:

- BTF (BPF Type Format) для CO-RE (Compile Once, Run Everywhere)
- Прямая трассировка ядра без внешних зависимостей

**Активация**: Используется автоматически вместо BCC, если доступно в профилях `standard`/`deep`. **Требует root** и современное ядро (≥ 5.8).

## Профили сбора данных

sysdiag поддерживает три профиля, контролирующих время сбора и набор инструментов:

| Профиль | Длительность | Возможности |
|---------|-------------|-------------|
| `quick` | 10 секунд | Уровень 1 (procfs). Работает без root. |
| `standard` | 30 секунд | **Включает Уровень 2/3** (гистограммы). Требует root. |
| `deep` | 60 секунд | **Включает все инструменты** (стеки, медленная ФС). Требует root. |

## Структура отчёта

Вывод — это один JSON-документ, разработанный для людей и машин:

```json
{
  "metadata": {
    "tool": "sysdiag",
    "hostname": "web-server-01",
    "profile": "standard"
  },
  "categories": {
    "cpu": [ "... результаты коллекторов ..." ],
    "memory": [ "..." ],
    "disk": [ "..." ],
    "network": [ "..." ]
  },
  "summary": {
    "health_score": 78,
    "anomalies": [
      { "severity": "warning", "message": "Утилизация CPU 87.3%" }
    ],
    "recommendations": [
      { "title": "Включить TCP BBR", "commands": ["sysctl -w ..."] }
    ]
  }
}
```

## Команды CLI

```bash
# Основная команда — сбор метрик системы
sudo sysdiag collect [флаги]
  --profile string    Профиль: quick|standard|deep (по умолчанию "standard")
  --focus string      Области фокуса (через запятую): cpu,disk,network,stacks
  --output string     Путь к файлу вывода (по умолчанию: stdout)
  --ai-prompt         Включить промпт для AI-анализа

# Сравнить два отчёта
sysdiag diff <baseline.json> <current.json> [--json]

# Проверить возможности системы
sysdiag capabilities

# Установить BPF-инструменты
sudo sysdiag install
```

---

*Далее: [Глава 1 — Основы Linux для анализа производительности](01-linux-fundamentals.md)*
