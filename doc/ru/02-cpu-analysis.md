# Глава 2: Анализ CPU — Глубокое погружение

## Обзор

CPU — самый фундаментальный ресурс. `CPUCollector` (`internal/collector/cpu.go`) читает `/proc/stat` дважды и вычисляет дельту.

## Функции

| Функция | Что делает | Источник данных |
|---------|-----------|----------------|
| `Collect()` | Два чтения с вычислением дельты | — |
| `readProcStat()` | Парсит агрегат + per-CPU тики + число переключений контекста | `/proc/stat` |
| `parseCPULine()` | Извлекает user/nice/system/idle/iowait/irq/softirq/steal | Поля stat |
| `computeDelta()` | Вычисляет процент из дельты тиков | Два сэмпла |
| `computePerCPUDeltas()` | То же, но для каждого логического CPU | Per-CPU stat |
| `readLoadAvg()` | Читает средние нагрузки 1/5/15 минут | `/proc/loadavg` |

## Формула вычисления

```
процент = (тики_после - тики_до) / (всего_после - всего_до) × 100
```

## Load Average — индикатор насыщения

| Нагрузка / Кол-во CPU | Значение |
|----------------------|----------|
| < 1.0 | Запас мощности |
| = 1.0 | На пределе |
| > 1.0 | Перегрузка — работа стоит в очереди |
| > 4.0 | Сильная перегрузка |

## Параметры CFS планировщика

| Параметр | По умолчанию | Назначение |
|----------|-------------|-----------|
| `sched_latency_ns` | 6 мс | Целевое время на полный раунд планирования |
| `sched_min_granularity_ns` | 0.75 мс | Мин. время выполнения задачи перед вытеснением |

## Что искать в результатах

- **Высокий user%** → CPU-bound приложение
- **Высокий iowait%** → Проблема с диском
- **Высокий steal%** → Гипервизор забирает CPU (VM)
- **Высокий softirq%** → Интенсивная сетевая обработка
- **Один CPU на 100%** → Однопоточное узкое место

---

*Далее: [Глава 3 — Анализ памяти](03-memory-analysis.md)*
