# Глава 2: Анализ CPU — Глубокое погружение

## Обзор

CPU — самый фундаментальный ресурс. `CPUCollector` (`internal/collector/cpu.go`) читает `/proc/stat` дважды и вычисляет дельту.

## Функции

| Функция | Что делает | Источник данных |
|---------|-----------|----------------|
| `Collect()` | Два чтения с вычислением дельты | — |
| `readProcStat()` | Парсит агрегат + per-CPU тики + число переключений контекста | `/proc/stat` |
| `parseCPULine()` | Извлекает user/nice/system/idle/iowait/irq/softirq/steal | Поля stat |
| `computeDelta()` | Вычисляет процент из дельты тиков | Два сэмпла |
| `computePerCPUDeltas()` | То же, но для каждого логического CPU | Per-CPU stat |
| `readLoadAvg()` | Читает средние нагрузки 1/5/15 минут | `/proc/loadavg` |

## Формула вычисления

```
процент = (тики_после - тики_до) / (всего_после - всего_до) × 100
```

## Load Average — индикатор насыщения

| Нагрузка / Кол-во CPU | Значение |
|----------------------|----------|
| < 1.0 | Запас мощности |
| = 1.0 | На пределе |
| > 1.0 | Перегрузка — работа стоит в очереди |
| > 4.0 | Сильная перегрузка |

## Параметры CFS планировщика

| Параметр | По умолчанию | Назначение |
|----------|-------------|-----------|
| `sched_latency_ns` | 6 мс | Целевое время на полный раунд планирования |
| `sched_min_granularity_ns` | 0.75 мс | Мин. время выполнения задачи перед вытеснением |

## Анализ задержек (Tier 2/3)

Обычные метрики (`user%`, `system%`) показывают утилизацию, но скрывают латентность. Инструменты BCC/eBPF (доступны в профилях `standard`/`deep`) позволяют увидеть скрытые проблемы:

### runqlat (Run Queue Latency)
Показывает, сколько времени процесс ждал CPU *после* того, как стал готов к выполнению.
- **Норма**: < 100 мкс
- **Проблема**: > 10 мс (CPU перегружен, процессы "тормозят")
- **Полезно для**: Анализа "фризов" в приложениях даже при неполной загрузке CPU.

### profile (CPU Flame Graph)
Сэмплирует стеки вызовов (99 раз в секунду), чтобы понять, **какой код** выполняется.
- Позволяет построить Flame Graph.
- Показывает горячие функции ядра и user-space (если есть символы).
- **Полезно для**: Поиска узких мест в коде (например, spinlocks, crypto, json parsing).

### softirqs
Детализирует время, потраченное на обработку программных прерываний (NET_RX, BLOCK, SCHED), которые часто скрыты в `softirq%`.

## Что искать в результатах

- **Высокий user%** → CPU-bound приложение
- **Высокий iowait%** → Проблема с диском
- **Высокий steal%** → Гипервизор забирает CPU (VM)
- **Высокий softirq%** → Интенсивная сетевая обработка
- **Один CPU на 100%** → Однопоточное узкое место

---

*Далее: [Глава 3 — Анализ памяти](03-memory-analysis.md)*
